[{"authors":null,"categories":null,"content":"\rO Git\r\rÉ um sistema de controle de versão distribuído gratuito e de código aberto projetado para lidar com tudo, de projetos pequenos a muito grandes, com velocidade e eficiência, além de ser fácil de aprender Ele usa recursos como ramificação local barata, áreas de preparação convenientes e vários fluxos de trabalho.\r\r\rCuriosidade: A microsoft migrou o seu sistema de controle de versão interna para o Git com o Github, pois somente para o windows há cerca de 4 mil desenvolvedores em todo mundo e o controle de versão da microsoft não estava dando conta.\n\r\rO Github\r\rÉ um conjunto de repositórios publicados no Git e na internet, ou seja, além de o usuário poder fazer o controle de versão na máquina com o GitHub ele também pode fazer esse controle de versão online em um único repositório protegido por usuário e senha, isso é o Github, ou seja, é um local na internet onde estão os diversos repositórios do Git em todo mundo. O github é usado por 28 milhões de pessoas, a plataforma é o maior repositório de código de programas do mundo.\r\r\rEm 2018 a Microsoft comprou GitHub por US$ 7,5 bilhões.\n\r\rConfigurando o git\rO git guarda suas informações em três lugares.\n * git config (do sistema como um todo)\r* git config (do usuário)\r* git config (do projeto)\rConfigure informações de usuário para todos os repositórios locais, como o nome e o email que você quer ligado às suas transações de commit.\nDefinindo configurações\rde usuário\rgit config --global user.name \u0026quot;nome do usuario\u0026quot;\r\rde e-mail\rgit config --global user.email \u0026quot;endereco-de-email\u0026quot;\r\rdo editor\rgit config --global core.editor \u0026quot;nome do editor\u0026quot;\r\r\rRetornando as configurações\rdo usuário\rgit config user.name\r\rdo e-mail\rgit config user.email\r\rde tudo\rgit config --list\r\r\r\rIniciando uma repo\rAgora que já temos o git instalado e configurado iremos criar um repositório (repo, pasta) no qual colocaremos os arquivos de nosso projeto.\nCriando uma repo.\rmkdir git-learn\rentrando na repo git-learn\rcd git-learn\r\rreconhecendo a repo.\rO comando git init faz com que a repo criada seja parte do ecossistema do git, ou seja, ele inicializa a repo e é o responsável por fazer com que o ecossistema do git enxergue todas as mudanças que ocorrerão na repo.\ngit init \r\ro que há dentro do diretório git-learn ?\rls -la\rComo abamos de inicializá-lo o diretório possui apenas um subdiretório .git.\n\ro que há dentro do diretório .git ?\rls \rAqui estão algumas pastas responsáveis por:\n\rconfig : Configuração do Repositório.\n\rHEAD : Branch padrão.\n\rbranches: Branches existentes do projeto.\rdescription: Descrição das branches.\n\rhooks: Catilhos para fazer certas ações,\r\re toda vez que inicializamos uma repo o git irá criar essas pastas para guardar todas as informações importantes para o bom gerenciamento da repo.\n\r\r\rWorkflow dos arquivos.\rDepois de algum tempo trabalhando com o git “+” github, você irá perceber que há um fluxo de trabalho no qual o usuário o compreende naturalmente, pois trata-se de estágios bem defindos que estabelecem um tipo de ciclo de vida dos arquivos.\n\rO workflow dos arquivos pode ser entedido como um ciclo de vida dos arquivos em quatros estágios bem definidos.\n\r\rUntracked\n\rUnmodified\n\rModified\n\rStaged\r\r\rFigure 1: Imagem retirada do site https://git-scm.com\r\rUntracked\rÉ o momento em que o arquivo acabou de ser adicionado no repositório, mas ainda não foi visto pelo git, ou seja, o git não reconhece em seu repositório em nenhuma versão a existência deste arquivo.\n\rUnmodified\rDepois que um arquivo é adicionado ele passa a ser considerado como não modificado, ou seja, ele já existe no git mas ainda não sofreu modificações.\n\rModified\rApós um arquivo ser reconhecido pelo git podemos então editá-lo e todo arquivo editado passa ao status de modificado.\n\rStaged\rDepois do arquivo ser modificado podemos colocá-lo em uma área onde será criada uma versão, a qual é chamada de staged.\n\rCommit\rOs arquivos comitados passam ao status de unmodified, pois uma vez que a versão de um arquivo foi criada e comentada nada foi alterado.\n\r\rStatus do arquivo\rAntes de fazer modificações nos arquivos da repo, é altamente recomendado que você dê o comando git status que irá retornar os arquivos de acordo com o estágio no(s) qual(is) se encontra(m) no worflow. Por exemplo, suponha que após digitarmos git status observemos que há um arquivo no estágio untracked o que implica que ainda não podemos commitá-lo, sendo necessário primeiramente subir esse arquivo para o git usando o git add [nome do arquivo].\ngit status\rServe pra reportar como está o meu repositório neste momento.\ngit status\rSe não existir nada ainda em seu repositório irá aparecer a seguinte mensagem:\n\r\r\rOn branch master: significar que você está na branch master\n\rInicial commit : ainda não tive nenhum commit\n\rnothing to commit: não tenho nada para commitar\n\r\rComo ainda não há arquivos em nosso repositório, iremos criá-lo usando um editor de texto vim.\nvim Readme.md\r\r\r\rCriado o arquivo Readme.md criado vamos agora inserir um texto nele.\rPressione a tecla i para passarmos ao modo de inserção.\n\rDigite a frase Curso básico de gite github.\rPressione ESC para voltar ao modo de comando.\rDigite :wq e sem seguida pressione o Enter.\r\rObs: O comando (:wq) é utilizado para salvar (salve) o arquivo e sair (quit) do Vim. \nAgora podemos verificar novamente o status\ngit status\r\r\rObserve que o arquivo Readme.md está com seu status em untracked, ou seja, ele acabou de ser criado porém o git ainda não o reconhece, iremos adicioná-lo usando o comando git add [nome do arquivo] e em seguida digitaremos novamente o git status.\n\rgit add\rgit add Readme.md\r\r\rVeja, temos um novo arquivo reconhecido pelo git! O output indica que este é o momento do staged, agora o arquivo já pode ser commitado e preparado para criarmos uma versão dele.\n\r\rCommit nos arquivos\r\r\rObserve que o git nos mostra os arquivos de acordo com o estágio dentro do ciclo de vida do arquivo, e por isso temos os arquivos\n\rcommit_ars.png\rvery_status.png\r\rno primeiro estágio que é untracked, ou seja, ainda não foram reconhecidos pelo git, precisam ser adicionos e comitados. Já os arquivos\n\rReadme.md\rgithub.Rmd\r\rsão reconhecidos pelo git, porém como foram modificados precisam ser adicionados e commitados.\n\r\r\rO comando commit é usado no momento em que você quer avisar o git que ele já pode criar uma image (snapshop,versão) do(s) arquivo(s) que está(ão) no repositório.\n\rPrimeiro commit\rCommitando o arquivo Readme.md.\ngit commit -m \u0026quot;Add Readme\u0026quot; Readme.md \rObs: No texto do commit é importante escrever o que realmente ocorreu com o arquivo, para que caso tenha que retornar a uma determinada versão você se lembre facilmente da alteração que foi feita, isso contribui em muito para o desenvolvimento de código em equipe.\nfirstcommit\n\rNote que o commit foi criado na [branch master] com a hash 11ed80d e com o seguinte comentário “primeiro comit”. Após o commit de todos os arquivos, sobrou apenas o arquivo github.Rmd\n\r\r\r\rVisualizando os logs\rAtravés do comando git log podemos verificar os arquivos que foram versionados.\ngit logs\rlogs\n\rFiltrando os logs\r$ git shortlog --author=\u0026quot;sergio\u0026quot;\rSergio (6):\rprimeiro commit\rgitignore\rprojeto\rimagens\rgithub latex-referencias\rswp\rUma forma bastante interessante de visualizar os logs é utilizndo o comando git log –graph, observe.\ngit_log\n\r\rUsando a hash para ver o commits\rgit show [hash]\rO comando git show seguido pela hash de determinado commit nos mostra qual a alteração que houve ao commitar o arquivo.\ngitshow\n\r\r\rVisualizando o diff\rO Comando diff\rO comando diff permite a nós visualizarmos as mudanças feitas nos arquivos antes de salvar a versão e fazer o commit.\n\rExemplo:\rPelo git bash iremos criar o arquivo Comando_diff.md e trabalhar nele.\ngit subl Comando_diff.md \rDigite: entendendo o comando diff.\n\rO que foi mudou ?\rgit diff\rresultado\n\rObserve que git coloca um sinal de ‘+’ indicando que houve alguma modificação isso nos ajuda no sentido de que podemos visualizar e revisar as mudanças antes de enivar para que o git salve uma versão, por isso é sempre interesse utilizar o git diff antes de realizar o commit.\n\rOpções do git diff\rgit diff --name-only\rNesta opção o git retorna somente o nome do arquivo modificado.\n\rGit checkout\rO git checkout é utilizado para nos ajudar a desfazer coisas, por exemplo, suponha que acabamos de realizar alguma modificação em um arquivo e ai, antes de commitar digitamos o comando git diff, na hipótese de termos feito algo errado ou que apenas não gostamos da modificação realizada podemos resetar o arquivo com o comando git checkout que o arquivo voltará ao seu status de conteúdo antes da modificação.\ngit diff checkout [nome do arquivo]\r\rGit reset\rO comando git reset tem três variações:\n\rgit reset –soft: reset o commit mas deixar o arquivo no staged para ser commitado novamente.\rgit reset –mixed: reset o commit mas volta o arquivo para antes do unstaged, modified.\rgit reset –hard: reset todo o arquivo como se o commit sido feito.\r\rAs três formas de uso do git reset, soft, mixed e hard, são acompanhadas da hash que indica que o reset será dado nas modificações posteriores a ela.\n\r\rRepositório Remoto (O github)\rNo github,\n\rCrie um repositório com o mesmo nome do nosso repositório local ()\rEm seguida, gere uma chave SSH em nosso computador de trabalho e adicioná-la ao github.\r\rObtenha uma URL existente\rCom o Git Bash criamos o repositório learning_git em ~/documents/estudos de analytics.\nO git clone\rSe um projeto já foi configurado em um repositório central, o comando git clone é a maneira mais comum para os usuários obterem um clone de desenvolvimento local. Como git init, a clonagem é geralmente uma operação única. Depois que um desenvolvedor obtiver uma cópia de trabalho, todas as operações de controle de versão serão gerenciadas por meio de seu repositório local.\ngit clone [repo url]\r\r\r\rSuprima o monitoramento\rIgnore arquivos e diretórios temporários\n\r*.log\rbuild/\rtemp-*\r\rUm arquivo de texto chamado .gitignore suprime o versionamento acidental de arquivos e diretórios correspondentes aos padrões especificados\ngit ls-files --others --ignored --exclude-standard\rLista todos os arquivos ignorados neste projeto\n\rComandos mais usados\rFaça mudanças\rRevise edições e crie uma transação de commit\ngit add [arquivo]\rFaz o snapshot de um arquivo na preparação para versionamento\ngit diff --staged\rMostra a diferença entre arquivos preparados e suas últimas versões\ngit reset [arquivo]\rRetira o arquivo da área de preparação, mas preserva seu conteúdo\ngit commit -m \u0026quot;[mensagem descritiva]\u0026quot;\rGrava o snapshot permanentemente do arquivo no histórico de versão\n\r\rMude e remova os arquivos versionados\rRemove o arquivo do diretório de trabalho e o prepara a remoção\ngit rm [arquivo]\rRemove o arquivo do controle de versão mas preserva o arquivo localmente\ngit rm --cached [arquivo]\rMuda o nome do arquivo e o prepara para o commit\ngit mv [arquivo-original] [arquivo-renomeado]\r\rSalve fragmentos\rArquive e restaure mudanças incompletas.\nArmazena temporariamente todos os arquivos monitorados modificados\ngit stash\rRestaura os arquivos recentes em stash\ngit stash pop\rLista todos os conjuntos de alterações em stash\ngit stash list\rDescarta os conjuntos de alterações mais recentes em stash\ngit stash drop\r\rMudanças em grupo\rNomeie uma série de commits e combine os esforços completos\rgit branch\rLista todos os branches locais no repositório atual\ngit branch [nome-do-branch]\rCria um novo branch\ngit checkout [nome-do-branch]\rMuda para o branch especificado e atualiza o diretório de trabalho\ngit merge [nome-do-branch]\rCombina o histórico do branch especificado ao branch atual\ngit branch -d [nome-do-branch]\rExclui o branch especificado\n\r\rRevise o histórico\rNavegue e inspecione a evolução dos arquivos do projeto\rgit log --follow [arquivo]\rLista o histórico de versões para o branch atual\ngit log --follow [arquivo]\rLista o histórico de versões para um arquivo, incluindo mudanças de nome\ngit diff [primerio-branch]...[segundo-branch]\rMostra a diferença de conteúdo entre dois branches\ngit show [commit]\rRetorna mudanças de metadata e conteúdo para o commit especificado\n\r\rDesfaça commits\rApague enganos e crie um histórico substituto\rgit reset [commit]\rDesfaz todos os commits depois de [commit], preservando mudanças locais\ngit reset --hard [commit]\rDescarta todo histórico e mudanças para o commit especificado\n\r\rSincronize mudanças\rRegistre um repositório remoto e troque o histórico de versão\rgit fetch [nome-remoto]\rBaixe todo o histórico de um repositório remoto\ngit merge [nome-remoto]/[branch]\rCombina o branch remoto ao branch local atual\ngit push [alias] [branch]\rEnvia todos os commits do branch local para o GitHub\ngit pull\rBaixa o histórico e incorpora as mudanças\n\r\rReferências\r\rGit-Try-Io\rLearngitbranching”\rGit-SCM\rGitLab\rGitfordummys\rGetting Git Right\r\r\r","date":1543363200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1543363200,"objectID":"683e886fdf92ef0da769d409ab652b48","permalink":"https://sergiocarvalho-estatistico.github.io/tutorial/2018-11-28-github/","publishdate":"2018-11-28T00:00:00Z","relpermalink":"/tutorial/2018-11-28-github/","section":"tutorial","summary":"O Git\r\rÉ um sistema de controle de versão distribuído gratuito e de código aberto projetado para lidar com tudo, de projetos pequenos a muito grandes, com velocidade e eficiência, além de ser fácil de aprender Ele usa recursos como ramificação local barata, áreas de preparação convenientes e vários fluxos de trabalho.\r\r\rCuriosidade: A microsoft migrou o seu sistema de controle de versão interna para o Git com o Github, pois somente para o windows há cerca de 4 mil desenvolvedores em todo mundo e o controle de versão da microsoft não estava dando conta.","tags":null,"title":"O que é o git e Github ?","type":"tutorial"},{"authors":null,"categories":["Inteligência Artificial","Inferência Bayesiana"],"content":"\rRESUMO\rRedes Bayesianas é um método de modelagem e de decisão baseado em incerteza conhecida como redes de opinião, redes causais e gráficos de dependência probabilística, que combina probabilidade e conhecimento prévio do problema afim de determinar a probabilidade final de uma hipótese. Seus nós representam as variáveis (discretas ou contínuas), e os arcos representam conexões diretas entre eles.\nPor pemitir uma abordagem interpretativa e analítica tem as Redes Bayesianas tem sido utilizada para:\n\rEstimação de risco operacional\rDiagnóstico médico,\rCredit scoring,\rProjeto de jogos computacionais,\rImputação de dados, entre outras.\r\rDesta forma, as Redes Bayesianas pode ser utilizada para fins de:\n\rDecisão\rClassificação\rAnálise de dependência entre variáveis,\r\rsendo uma alternativa às técnicas comumente utilizadas como, por exemplo, Regressão Logística e Análise Discriminante.\n\rUma Breve Revisão da Teoria de Probabilidades\rDefinição\rA definição axiomática de probabilidade, dada por Komolgorov em 1933, é comumente adotada e considera que a probabilidade é uma função definida numa classe \\(\\tau\\) de eventos de \\(\\Omega\\) que satisfaz as seguintes condições:\n\\(P(A) \\geq 0\\)\n\rSe \\(\\cap_{i=1}^{\\infty} A\\_i = \\varnothing \\Longrightarrow P( \\cup_{i=1}^{\\infty} A\\_i) = \\displaystyle \\sum_{i=1}^{\\infty} P(A\\_i)\\)\n\r\\(P(\\Omega) = 1\\).\n\r\r\rProbabilidade condicional\rA probabilidade condicional trata do fato de que muitas vezes temos conhecimento que um determinado evento já ocorreu, desta forma surge o interesse de calcular a probabilidade de outro evento de interesse e possivelmente relacionado ao evento anterior. Denotamos como P( E | F ) à probabilidade de ocorrência do evento E, sabendo que o evento F ocorreu, ou simplesmente, a probabilidade de E dado F. Desta forma, temos:\n\r\\(P(E|F) = \\dfrac{P(E\\cap F)}{P(F)}\\)\n\rAnalogamente,\n\r\\(P(E\\cap F) = P(E|F)P(F) ~~ \\text{ou} ~~ P(E\\cap F) = P(F|E)P(E)\\)\n\rgeneralizando, temos que:\n\r\\(\\small P(E_1,E_2,\\cdots,E_n) = P(E_1)P(E_2|E1)P(E_3|E_1,E_2) \\cdots P(E_n|E_1, E_2, \\cdots, E_{n-1})\\)\n\rentão, podemos escrever que:\n\r\\(P(F) = \\displaystyle \\sum_{i=1}^{n} P(F|E_i)P(E_i)\\)\n\r\rIndependência probabilística\rPodemos considerar que os eventos E e F são independentes quando existe a relação.\n\r\\(P(E|F) = P(E) ~~ \\text{ou} ~~ P(F|E) = P(F)\\)\n\r\rTeorema de Bayes\rComo anteriormente, considere o evento \\(F\\) e \\(E_i, \\cdots , E_n\\) eventos exclusivos e exaustivos, ou seja, que não possuem intersecção e que a união deles forma o espaço amostral. Assim, o Teorema de Bayes é definido por.\n\r\\(P(E_j | F) = \\dfrac{P(E_j)P(F|E_j)}{\\displaystyle \\sum_{j = 1}^{n} P(E_j)P(F|E_j)}\\)\n\rO teorema de Bayes é uma junção do teorema de probabilidade condicional e da fórmula de probabilidades totais. Assim, \\(P(E_j)\\) pode ser denominada como probabilidade a priori, \\(P( F ~ | ~ E_j )\\) como verossimilhança e \\(P(E_j ~|~ F)\\) como probabilidade a posteriori, ou seja, a probabilidade posterior à observação do evento F. Além disso, o denominador é a decomposição de \\(P(E)\\) , ou seja, pode se considerado como constante normalizadora; desta forma, pode ser reescrito na forma.\n\r\\(P(E_j ~|~ F) ~ ~ \\propto ~ ~ P (E_j) ~ P(F ~|~ E_j)\\)\n\rsendo \\(~ \\propto ~\\) indicador de proporcionalidade. Em outros termos, podemos dizer que a probabilidade a posteriori é proporcional à probabilidade a priori multiplicada pela verossimilhança.\n\rAs distribuições Multinomial e Dirichlet\rEstas duas distribuições, aqui introduzidas, são amplamente utilizadas no contexto de Redes Bayesianas quando métodos de estimação bayesiana são requeridos. Considere uma variável aleatória X discreta que represente um experimento com r possíveis resultados, sendo que cada tipo de resultado possui uma probabilidade específica \\(P(X = x_i) = p_i ~ ~ \\text{e} ~ ~ \\displaystyle \\sum_{i = 1}^{r} p_i = 1\\). Além disso, o experimento é repetido de forma independente N vezes, de forma que a variável \\(X_i\\) seja o número de vezes que o resultado \\(x_i\\) está presente na amostra com \\(i=1, \\cdots,r\\). Temos que a variável \\(X\\) segue distribuição Multinomial, sendo sua função densidade de probabilidade expressa pela fórmula.\n\r\\(P(X ~|~ N,~ p) ~ = ~ \\dfrac{N!}{\\displaystyle \\prod_{i=1}^{r} x_i!} \\displaystyle \\prod_{i=1}^{r} p_i^{xi} ~ ~ ~ , ~ ~ ~ \\text{em que} ~ ~ ~ \\sum_{i=1}^{r} x_i = N\\)\n\rConsiderando o termo \\(\\dfrac{N!}{\\displaystyle \\prod_{i=1}^{r} x_i!}\\) como normalizador, temos\n\r\\(P(X ~|~ N,~ p) ~ \\propto ~ \\displaystyle \\prod_{i=1}^{r} p_i^{xi}\\)\n\rAlém disso, temos que para um vetor \\(p=(p_1, p_2, ~\\cdots ~,p_r)\\) de valores desconhecidos com\\(\\displaystyle \\sum_{i=1}^{r} p_i = 1\\), podemos assumir que \\(p\\) segue distribuição Dirichlet com parâmetros \\(\\alpha = (\\alpha_1, ~\\cdots ~, \\alpha_r)\\) com \\(\\alpha_i \u0026gt; 1\\), \\(E(p_i) = \\dfrac{\\alpha_i}{\\alpha_0}\\) e função densidade de probabilidade expressa pela fórmula.\n\r\\(P(~ p ~|~ \\alpha) = \\dfrac{\\Gamma(\\alpha_0) }{\\displaystyle \\prod_{i=1}^{r} \\Gamma(\\alpha_i) } \\displaystyle \\prod_{i=1}^{r} p_i^{\\alpha_i - 1}\\)\n\rem que podemos considerar o termo \\(\\dfrac{\\Gamma(\\alpha_0) }{\\displaystyle \\prod_{i=1}^{r} \\Gamma(\\alpha_i) }\\) como normalizadorc, temos que:\n\r\\(P(~ p ~|~ \\alpha) = \\displaystyle \\prod_{i=1}^{r} p_i^{\\alpha_i - 1}\\)\n\rassumindo como priori \\(P( p ~|~ \\alpha)\\) e como verossimilhança \\(P(X ~|~ N,~ p)\\), temos que a posteriori \\(P( p ~|~ X )\\) é dada pela expressão abixo a qual tem distribuição Dirichlet com parâmetros \\(α = (α_1+x_1, . . . , α_r+x_r)\\), ou seja \\(E(p_i) = \\dfrac{\\alpha_i+x_i}{\\alpha_0 + N}\\) , sendo \\(\\displaystyle \\alpha = \\sum_{i = 1}^{r} \\alpha_i.\\) \r\r\\(P(p ~|~ X) \\propto \\displaystyle \\prod_{i}^{r} p_{i}^{\\alpha_i + x_i - 1}\\)\n\rNotamos que neste caso a posteriori possui o mesmo tipo de distribuição que a priori, assim dizemos que a família Dirichlet é conjugada para amostras com distribuição Multinomial.\n\r\rRedes Bayesianas\rAs Redes Bayesianas permite medir qual a influência probabilística não direta de uma variável para as demais, inclusive quando há um grande número de variáveis. Além disso, ela pode ser considerada como uma representação visual e informativa da tabela de probabilidade conjunta de todas as variáveis que envolvem o domínio do problema.\nElementos Básicos da Teoria de Grafos\rA teoria de Redes Bayesianas é construída considerando grafos direcionados, conectados e acíclicos DAG (directed acyclic graph). O estudo dos grafos investiga as relações entre seus elementos, os nós e arcos. Os nós, círulos, representam as variáveis aleatórias do problema. Os arcos, setas, e representam a dependência probabilística direta entre duas variáveis.\n\rFigure 1: Exemplo de Nó e Arco\r\r\rEstruturas básicas existentes dentro da Teoria de grafos\rO termo “direcionado” faz referência à presença de direção dos arcos, o termo “conectado” é utilizado para designar que todos os nós estão conectados na rede e, por fim, o termo “acíclico” se refere à propriedade de não retorno para um nó após seguida a direção dos arcos.\n\rFigure 2: Estrutura básica\r\rDa da figura acima, notamos que as Redes Bayesianas envolvem apenas alguns tipos de estruturas básicas:\n\rEstrutura de conexões simples: Existe apenas um caminho que liga uma variável a outra independente da direção dos arcos\rEstrutura de múltiplas conexões: Há mais de um possível caminho que liga uma variável a outra, independente da direção dos arcos.\r\rA subdivisão das estruturas de conexão simples se dá pelo número de nós que originam a rede, ou seja, nós que não possuem nenhum arco chegando, apenas arcos partindo.\n\rHierarquia Entre Nós\rA relação de dependência direta entre dois nós por meio do arco que os conecta é denominada por pai e filho, o nó de onde o arco parte é designado nó pai, o nó de onde o arco chega com sua ponta é designado nó filho. Além disso, um nó que não possui filhos é chamado de folha e um nó que origina a rede, ou seja, que não possui pais, é chamado de raiz.\n\rFormalização Estatística da Estrutura\rNo contexto estatístico o termo nó A será substituído pelo termo variável A, a qual pode ser contínua ou discreta, apesar de alguns pesquisadores afirmarem que as Redes Bayesianas é primeiramente direcionada ao tratamento de variáveis discretas. Porém, as variáveis contínuas podem ser facilmente transformadas em variáveis discretas. Por exemplo, é condição básica a uma variável discreta não possuir variáveis pai contínuas. Neste contexto uma Rede Bayesiana é definida pelo trio \\((\\varepsilon, \\theta, X )\\), onde \\(\\varepsilon\\) é uma estrutura DAG e \\(\\theta\\) é um conjunto de parâmetros específicos de distribuições de probabilidades condicionais envolvendo um conjunto \\(X\\) de variáveis aleatórias discretas.\n\rTabela de probabilidade condicional\rOutro elemento importante dentro da estrutura de Redes Bayesianas é a tabela de probabilidade condicional (CPT). Trata-se da exibição dos parâmetros de probabilidade condicional da variável sendo condicionada a seu(s) pai(s). Por exemplo, dado o conjunto de três variáveis A, B e C, todas dicotômicas assumindo valores binários, onde A e B são pais da variável C, temos a tabela abaixo.\n\r\r\rC\rA\rB\r\\(P(C \\text{|} A,B)\\)\r\r\r\r1\r1\r1\r\\(\\theta_1\\)\r\r1\r1\r0\r\\(\\theta_2\\)\r\r1\r0\r1\r\\(\\theta_3\\)\r\r1\r0\r0\r\\(\\theta_4\\)\r\r0\r1\r1\r\\(\\theta_5\\)\r\r0\r1\r0\r\\(\\theta_6\\)\r\r0\r0\r1\r\\(\\theta_7\\)\r\r0\r0\r0\r\\(\\theta_8\\)\r\r\r\r\r\rExemplo Básico de uma Rede Bayesiana\rConsidere uma Rede Bayesiana dada sua estrutura já conhecida e relacionando seguintes variáveis binárias:\n\rSexo { M, F };\rIdade { \u0026lt;20 anos, \u0026gt;= 20 anos };\rCréditos Anteriores { 1, \u0026gt;1 };\rCredit Rating { Bom , Ruim }\r\rAssim, a rede é representada pela Figura abaixo:\n\rFigure 3: Exemplo da Estrutura de Modelagem das Redes Bayesianas\r\rObservando a figura acima que as variáveis\n\rSexo,\rIdade,\rCréditos Anteriores,\rCredit Rating,\r\rsão representadas por seu respectivo nó na rede, sendo Sexo e Idade variáveis-pai da variável Crédtios Anteriores e Créditos Anteriores pai da variável Credit Rating. Ainda realizando uma análise hierárquica, as variáveis Sexo e Idade são classificadas na rede como variáveis-raiz e Credit Rating como folha.\nAlém disso, notamos que Sexo e Idade influenciam diretamente a variável Créditos Anteriores, que por sua vez influencia probabilisticamente de uma forma direta a variável Credit Rating. Interpretando os relacionamentos, se o cliente é do sexo masculino, ou não, isso influencia na probabilidade do cliente ter um, ou mais, créditos anteriores realizados na instituição. Se o cliente é menor de 20 anos, ou não, também influencia a probabilidade do cliente ter um ou mais créditos anteriores realizados na instituição. Assim, a probabilidade do cliente ter, ou não, realizado requisição de créditos anteriormente na instituição financeira influencia a probabilidade dele ser classificado como um bom pagador ou mau pagador. Para cada uma das variáveis e seus cruzamentos condicionais, temos uma tabela de probabilidade condicional (CPT) explicando numericamente a chance da cada categoria – evento – ocorrer dado premissas anteriores.\n\rFigure 4: Rede Bayesiana tendo como evidencia a variável Idade (Idade \u0026lt;20)\r\r\r\rConceitos Importantes\rEvidência\rDada a estrutura gráfica DAG, outra definição é importante para a teoria de Redes Bayesianas. Esta é denominada como evidência e refere-se ao fato de uma variável ser indicada pelo usuário da rede, ou seja, uma variável aleatória com valor conhecido e acoplado à Rede Bayesiana com estrutura já conhecida. Basicamente, podemos definir uma evidência com uma observação.\nConsidere o exemplo da Figura 2.3. Desta forma, observamos que um novo cliente possui a idade de 18 anos; assim, na rede, indicamos a variável Idade para a categoria respectiva, ou seja, definimos Idade \u0026lt;20 anos. A variável idade é classificada como uma evidência para a rede. A Figura 2.4 exibe uma demonstração visual para Idade \u0026lt;20 anos. As evidências são úteis quando existe o objetivo de realização de inferência probabilística para a rede em estudo. Este procedimento será visto com mais detalhes posteriormente.\n\rAs propriedades Markovianas\rAssim como em alguns tipos de processos estocásticos, a dinâmica de uma Rede Bayesiana é controlada pela propriedade de Markov, a qual rege que não existem dependências diretas entre as variáveis de uma Rede Bayesiana que não estão explícitas através da apresentação orientada dos arcos, ou seja, cada variável possui dependência direta apenas de sua (s) variável (eis) pai.\nA partir de todas as propriedades acima, temos que uma Rede Bayesiana é um par \\((\\varepsilon,\\theta)\\) definido sobre um conjunto de variáveis aleatórias \\(X = \\{ X_1, X_2, \\cdots , X_k \\}\\), onde cada \\(X_i\\) corresponde a uma variável da rede, satisfazendo a propriedade de Markov:\n\r\\(P[X_i ~|~ X_j,~ pais(X_i)] = P[X_i ~|~ pais(X_i)]\\)\n\rAlém disso, consideremos a distribuição de probabilidade conjunta de uma Rede Bayesiana com k variáveis e a propriedade (2.1), temos que em uma Rede Bayesiana \\((\\varepsilon,\\theta )\\) , definida sobre um conjunto de variáveis aleatórias \\(X = \\{ X_1, X_2, \\cdots , X_k \\}\\), a probabilidade conjunta de toda a rede é dada através da expressão.\n\r\\(P(X_i = x_i, \\cdots , X_k = x_k ) = \\prod_{i = 1}^{k} P[X_i ~ | ~ pais(X_i) ]\\)\n\rOu seja, as propriedades probabilísticas estão intimamente ligadas com o condicionamento da variável com seu (s) pai (s) respectivo (s). Note que (2.2) é resultado direto do desenvolvimento do Teorema de Bayes visto na seção 1.3.2.4., dada a propriedade (2.1).\nPara o exemplo da Figura 2.3, a variável Sexo e Idade são independentes, pois não existe nenhum arco relacionando-as. Além disso, Credit Rating é diretamente independente de Sexo e Idade, a variável Credit Rating depende apenas diretamente da variável Créditos Anteriores, a qual é sua variável-pai.\nUma Rede Bayesiana na qual cada dependência probabilística entre as variáveis é dadapor um único arco é chamada de Rede perfeita (Korb e Nicholson, 2004).\nOutro conceito muito utilizado na teoria de Redes Bayesianas é a cobertura de Markov, que consiste no conjunto formado pelas variáveis-pai, variáveis-filhos e pais dos filhos de uma determinada variável. Como exemplo, temos que a cobertura de Markov para a variável Idade da Figura 2.4 envolve a variável Créditos Anteriores (variável-filho da variávelIdade) e a variável Sexo (variável-pai de uma variável-filho da variável Idade), note que a variável Idade não possui variáveis-pai, se estas existissem seriam consideradas na cobertura de Markov. Outro exemplo de cobertura de Markov pode ser visualizado na Figura 2.5 que exibe a cobertura de Markov para a variável A.\n\rFigure 5: Cobertura de Markov de A representada pelas variáveis-nó cinza\r\r\rA propriedade de d-separação.\rAtravés das propriedades markovianas, notamos que uma variável é independente de outra se não existe nenhum arco conectando-as. Porém, é possível definir independência quando existe entre as variáveis analisadas um grupo específico de variáveis, podendo ser um grupo de evidências, por exemplo. Neste caso, surge a conceito de d-separação. Para defini-la consideremos alguns tipos de conexões dadas em Neopolitan (2004). Seja X, Z e Y variáveis de uma Rede Bayesiana \\((\\varepsilon,V)\\) , definimos alguns tipos de conexão:\n\rSe \\(X ~ \\rightarrow ~ Z ~ \\rightarrow ~ Y\\), temos um relacionamento head-to-tail;\rSe \\(X ~ \\leftarrow ~ Z ~ \\rightarrow ~ Y\\), temos um relacionamento tail-to-tail;\rSe \\(X ~ \\rightarrow ~ Z ~ \\leftarrow ~ Y\\), temos um relacionamento head-to-head\r\r\rAlém disso, podemos definir \\(A \\subset \\vee\\), sendo \\(X e Y \\in \\vee - A\\). Desta forma, para os casos 1 e 2, se consideramos que \\(Z \\in A\\) , a variável \\(Z\\) bloqueará o caminho entre \\(X ~\\text{e}~ Y\\). Para o caso 3, se consideramos que Z e seus descendentes  A, a variável Z bloqueará o caminh entre X e Y. Se o caminho entre duas variáveis, ou conjunto de variáveis, é bloqueado, dizemos que essas variáveis, ou conjuntos, são d-separados. A Figura 2.6, retirada de Marques e Dutra (1999), ilustra os três casos de d-separação, onde os conjuntos U e W são d-separados.\n\rFigure 6: Tipos de d-separação, U e W d-separados\r\r\rEquivalência de Markov\rExistem inúmeras estruturas possíveis no enredo de Redes Bayesianas. Porém, podemos construir para cada conjunto de variáveis um grupo de estruturas extremamente semelhantes, chamadas de equivalentes de Markov. Segundo Neapolitan (2004), dois grafos são equivalentes quando mantêm as mesmas independências condicionais. Ou seja, dois grafos são considerados equivalentes quando conservam as mesmas ligações de arcos entre as variáveis independente da direção, com exceção às ligações head-to-head, ou seja, quando uma variável-filho possui mais que uma variável-pai. Assim, considere o exemplo da Figura 2.7.\n\rFigure 7: Exemplo de identificação de redes Bayesianas Markov equivalentes\r\rAnalisando a Figura 2.7, notamos que a estrutura (a) não é equivalente a (b), pois além de não preservar a conexão head-to-head \\(C ~ \\rightarrow ~ E ~ \\leftarrow ~ D\\) , a estrutura (b) não mantém a conexão entre as variáveis A e B. Esses mesmos motivos fazem (b) não equivalente à estrutura (c). Comparando a estrutura (a) com (c), notamos que existe apenas diferença entre a direção de ligação entre as variáveis A e B, ou seja, (a) e (c) são equivalentes. Dizemos que (a) e (c) pertencem à mesma classe de equivalência markoviana.\n\r\rMétodo Geral para a Construção de uma Rede Bayesiana.\rA construção de uma Rede Bayesiana não é trivial, além de existir vários métodos para a estimação de estruturas de rede através do conjunto de dados, os métodos podem ser influenciados por fatores como a ordem e escolha das variáveis que compõem o problema. Esse problema proporciona atualmente intensas pesquisas buscando um método ótimo para estimação de estruturas DAG para domínios de problemas práticos. Porém, de uma forma geral, Pearl (1988) criou um algoritmo baseando-se nas propriedades 2.1 e 2.2, no qual, dado um conjunto de variáveis discretas ordenadas, constrói uma Rede Bayesiana única, adicionando às variáveis a rede em sua ordem e acrescentando arcos para a formação da estrutura. Assim, cada variável é conectada às variáveis antigas da rede, o que garante que a estrutura seja sempre acíclica.\nO algoritmo de Pearl é dado abaixo.\nEscolha um conjunto de variáveis \\(X_i\\) que em suposição descreva o problema;\rEscolha uma ordem para as variáveis;\rPara todas as variáveis em ordem, faça:\rEscolha a variável \\(X\\) e adicione-a na rede;\rDetermine os pais da variável \\(X\\) dentre os nós que já estão na rede, que satisfaça \\(P[X_i~|~ X_j,~ pais(X_i)] = P[X_i| pais(X_i)]\\)\rConstrua a tabela de probabilidade condicional (CPT) para X.\r\r\rPara uma Rede Bayesiana ser adequada, ela deve ser perfeita, ou seja, todos arcos devem expressar corretamente as dependências entre as variáveis. Desta forma, é fácil notar que para a construção de uma Rede Bayesiana devemos escolher uma ordem correta para as variáveis, pois diferentes ordens podem gerar Redes Bayesianas diferentes. Desta forma, Korb e Nicholson (2004) sugerem que primeiramente consideremos as variáveis possíveis a serem raízes e suas variáveis independentes, a seguir as demais variáveis. Outros métodos de construção de Redes Bayesianas serão apresentados no decorrer do trabalho.\n\rResumo\rInferência em Redes Bayesinas\rNo contexto de Redes Bayesianas, o termo “inferência”, também conhecido como atualização de crença (belief updating), é comumente utilizado para referenciar a atualização de probabilidades por toda a estrutura da rede dada um conjunto de evidências. Ou seja, segundo Korb e Nicholson (2004), trata-se de um mecanismo para cálculo da distribuição posteriori de probabilidade para um conjunto de variáveis, dado um conjunto de evidências, ou seja, variáveis aleatórias com valores instanciados.\nPorém, como visto anteriormente, existem diversos tipos de estruturas de Redes Bayesianas, assim as inferências probabilistas podem ser realizadas de diferentes formas assumindo tipos de estruturas específicas e com diferentes quantidades de variáveis.\nEntretanto, existem fatores que dificultam o processo de inferência, como a complexidade da estrutura em análise e o número de variáveis. Ou seja, para poucas variáveis e uma estrutura gráfica dirigida acíclica (DAG) não complexa, a propagação das probabilidades pode ser facilmente calculada. À medida que existe um grande número de variáveis e estruturas mais complexas, existe grande dificuldade no cálculo das probabilidades da rede.\nMarques e Dutra (1999) consideram que existe maior dificuldade quando o problema é modelado de uma forma complexa, ou seja, quando a estrutura considerada para a inferência possui relações complexas entre as variáveis. Assim, em algumas situações, uma rede com apenas uma dezena de variáveis pode necessitar de um tempo computacional muito grande para término da inferência (às vezes inviável), enquanto uma rede contendo milhares de variáveis e uma estrutura simplista pode levar apenas alguns instantes de processamento.\nBuscando contornar tal problema, utilizamos algoritmos de inferência probabilística que facilitem os cálculos, sendo essa uma área de pesquisa em Redes Bayesianas.\nDeste modo, alguns algoritmos são utilizados de forma particular para tipos gerais de estruturas, basicamente as estruturas citadas na seção 2.1.2. Considerando as estruturas mais comuns, existem dois tipos de algoritmos para realizar inferência probabilista, estes são chamados de algoritmos exatos e algoritmos aproximados. Os algoritmos exatos produzem resultados mais satisfatórios, porém exigem um grande esforço computacional na presença de um alto número de variáveis na rede. Os algoritmos aproximados são construídos através de métodos de simulação, tendo uma precisão inferior, porém maior velocidade de processamento que os algoritmos exatos.\nNeste capítulo, serão expostos os mais comuns tipos de algoritmos exatos e aproximados, bem como suas utilizações em diferentes tipos de estruturas de Redes Bayesianas.\n\r\rAlgoritmo de Inferência Exata\r\rAplicação: Fatores de Risco em Trombose Coronária\rConjunto de Dados\rO conjunto de dados contém 6 variáveis com prováveis fatores de risco para trombose coronária, compreendendo dados de 1841 homens.\n#Coleta da Base de Dados Coronary\rcoronary \u0026lt;- bnlearn::coronary %\u0026gt;% data.frame()\rstr(coronary)\r## \u0026#39;data.frame\u0026#39;: 1841 obs. of 6 variables:\r## $ Smoking : Factor w/ 2 levels \u0026quot;no\u0026quot;,\u0026quot;yes\u0026quot;: 1 1 1 1 1 1 1 1 1 1 ...\r## $ M..Work : Factor w/ 2 levels \u0026quot;no\u0026quot;,\u0026quot;yes\u0026quot;: 1 1 1 1 1 1 1 1 1 1 ...\r## $ P..Work : Factor w/ 2 levels \u0026quot;no\u0026quot;,\u0026quot;yes\u0026quot;: 1 1 1 1 1 1 1 1 1 1 ...\r## $ Pressure: Factor w/ 2 levels \u0026quot;\u0026lt;140\u0026quot;,\u0026quot;\u0026gt;140\u0026quot;: 1 1 1 1 1 1 1 1 1 1 ...\r## $ Proteins: Factor w/ 2 levels \u0026quot;\u0026lt;3\u0026quot;,\u0026quot;\u0026gt;3\u0026quot;: 1 1 1 1 1 1 1 1 1 1 ...\r## $ Family : Factor w/ 2 levels \u0026quot;neg\u0026quot;,\u0026quot;pos\u0026quot;: 1 1 1 1 1 1 1 1 1 1 ...\r\r\rSmoking ( Tabagismo ).\rM. Work ( Trabalho mental extenuante ).\rP. Work ( Trabalho físico extenuante ).\rPressure ( Pressão arterial sistólica ).\rProteins ( Proporção de beta e alfa lipoproteínas ).\rFamily ( Anamnese familiar de doença coronária ).\r\r\r\rEstrutura de Aprendizagem\rExistem vários algoritmos de aprendizagem de estruturas em Redes Bayesianas e alguns estão disponíveis no pacote bnlearn, vamos utilizar o algoritmo Hill Climbing.\n# Aprendizagem da rede bayesiana usando algoritmo Hill-Climbing (HC)\rres \u0026lt;- hc(coronary)\rA representação gráfica abaixo mostra a relação de dependência condicional entre as variáveis.\n#Plot da Rede\rplot(res)\rObserve como o nó Pressure é influenciado pelo nó Smoking. No entanto, não faz muito sentido o nó Family, ser influenciado pelo nó M. Work, e neste caso, vamos modificar a estrutura gerada removendo o link entre os nós M. Work e Family.\n#Remover o Link entre nós \u0026quot;M..Work\u0026quot;, \u0026quot;Family\u0026quot;\rres \u0026lt;- drop.arc(res,\u0026quot;M..Work\u0026quot;,\u0026quot;Family\u0026quot;)\r#Plot da Rede\rplot(res)\r\r\rTabelas de Probabilidade Condicional.\rA função bn.fit nos retorna as tabelas de probabilidade condicional ( CPTs ) em cada nó, calculado pelo algoritmo EM (Expectation–Maximization).\n#Rede Bayesiana Ajustada\rbnfit \u0026lt;- bn.fit(res, data = coronary)\rAnalisando as probabilidades condicionais geradas para o nó Pressure (Pressão).\n#Tabela de Probabilidade Condicional - Pressure\rbnfit$Pressure\r## ## Parameters of node Pressure (multinomial distribution)\r## ## Conditional probability table:\r## ## Smoking\r## Pressure no yes\r## \u0026lt;140 0.5359001 0.6125000\r## \u0026gt;140 0.4640999 0.3875000\rObserve que o nó Pressure é condicionado a variável Smoking, conforme a representação gráfica da Rede Bayesiana.\n\rExtraindo valor da Análise.\rAs Redes Bayesianas nos permite a atualização das probabilidades de toda a estrutura da rede dada um conjunto de evidências através da distribuição de probabilidade a posteriori dado um conjunto de variáveis.\nO processo de inferência podem ser realizado sobre as Redes Bayesianas, em quatro maneiras distintas:\n\r\rDiagnósticos: partindo dos efeitos para as causas;\rCausa: partindo das causas para os efeitos;\rIntercausal: entre causas de um efeito comum;\rMistas: combinação de dois ou mais tipos descritos acima.\r\r\rProbabilidades de um evento.\rComparar as probabilidades de um indivíduo ter Pressure \u0026gt; 140 para cada nível da variável Smoking dado que Proteins é ‘\u0026gt;3’.\n#Inferência em Redes Bayesianas\r100 * cpquery(bnfit, event = (Pressure==\u0026quot;\u0026gt;140\u0026quot;), evidence = (Smoking==\u0026quot;yes\u0026quot; \u0026amp; Proteins==\u0026#39;\u0026gt;3\u0026#39;)) %\u0026gt;% round(2)\r## [1] 41\r100 * cpquery(bnfit, event = (Pressure==\u0026quot;\u0026gt;140\u0026quot;), evidence = (Smoking==\u0026quot;no\u0026quot; \u0026amp; Proteins==\u0026#39;\u0026lt;3\u0026#39;)) %\u0026gt;% round(2)\r## [1] 45\r\r$ P(Pressure \u0026gt; 140 ~ | ~ Smoking = yes, ~ Proteins \u0026gt; 3) = 41 % $ $ P(Pressure \u0026gt; 140 ~ | ~ Smoking = no , ~ Proteins \u0026gt; 3) = 47 % $\n\r\r\rReferências\r\rGit-Try-Io\rLearngitbranching”\rGit-SCM\rGitLab\rGitfordummys\rGetting Git Right\r\r\\mu_{0}, \\mu\\geq \\mu_{0}$ --\r\r","date":1543104000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1543104000,"objectID":"586e1818512993c44aeb298bb9e00729","permalink":"https://sergiocarvalho-estatistico.github.io/post/2018-11-25-redesbayesianas/","publishdate":"2018-11-25T00:00:00Z","relpermalink":"/post/2018-11-25-redesbayesianas/","section":"post","summary":"RESUMO\rRedes Bayesianas é um método de modelagem e de decisão baseado em incerteza conhecida como redes de opinião, redes causais e gráficos de dependência probabilística, que combina probabilidade e conhecimento prévio do problema afim de determinar a probabilidade final de uma hipótese. Seus nós representam as variáveis (discretas ou contínuas), e os arcos representam conexões diretas entre eles.\nPor pemitir uma abordagem interpretativa e analítica tem as Redes Bayesianas tem sido utilizada para:","tags":["Probabilidade","Redes Probabilísticas"],"title":"Redes Bayesianas","type":"post"},{"authors":[],"categories":null,"content":"Click on the Slides button above to view the built-in slides feature.\n Slides can be added in a few ways:\n Create slides using Academic\u0026rsquo;s Slides feature and link using url_slides parameter in the front matter of the talk file Upload an existing slide deck to static/ and link using url_slides parameter in the front matter of the talk file Embed your slides (e.g. Google Slides) or presentation video on this page using shortcodes.  Further talk details can easily be added to this page using Markdown and $\\rm \\LaTeX$ math code.\n","date":1483236000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1483236000,"objectID":"96344c08df50a1b693cc40432115cbe3","permalink":"https://sergiocarvalho-estatistico.github.io/talk/example/","publishdate":"2017-01-01T00:00:00-02:00","relpermalink":"/talk/example/","section":"talk","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam.","tags":[],"title":"Example Talk","type":"talk"},{"authors":null,"categories":null,"content":"","date":1461726000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461726000,"objectID":"d1311ddf745551c9e117aa4bb7e28516","permalink":"https://sergiocarvalho-estatistico.github.io/project/external-project/","publishdate":"2016-04-27T00:00:00-03:00","relpermalink":"/project/external-project/","section":"project","summary":"An example of linking directly to an external project website using `external_link`.","tags":["Demo"],"title":"External Project","type":"project"},{"authors":null,"categories":null,"content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\n","date":1461726000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461726000,"objectID":"8f66d660a9a2edc2d08e68cc30f701f7","permalink":"https://sergiocarvalho-estatistico.github.io/project/internal-project/","publishdate":"2016-04-27T00:00:00-03:00","relpermalink":"/project/internal-project/","section":"project","summary":"An example of using the in-built project page.","tags":["Deep Learning"],"title":"Internal Project","type":"project"},{"authors":["GA Cushen"],"categories":null,"content":"More detail can easily be written here using Markdown and $\\rm \\LaTeX$ math code.\n","date":1441076400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1441076400,"objectID":"d77fa4a74076ffcd7ca6c21cfc27a4b2","permalink":"https://sergiocarvalho-estatistico.github.io/publication/person-re-id/","publishdate":"2015-09-01T00:00:00-03:00","relpermalink":"/publication/person-re-id/","section":"publication","summary":"Person re-identification is a critical security task for recognizing a person across spatially disjoint sensors. Previous work can be computationally intensive and is mainly based on low-level cues extracted from RGB data and implemented on a PC for a fixed sensor network (such as traditional CCTV). We present a practical and efficient framework for mobile devices (such as smart phones and robots) where high-level semantic soft biometrics are extracted from RGB and depth data. By combining these cues, our approach attempts to provide robustness to noise, illumination, and minor variations in clothing. This mobile approach may be particularly useful for the identification of persons in areas ill-served by fixed sensors or for tasks where the sensor position and direction need to dynamically adapt to a target. Results on the BIWI dataset are preliminary but encouraging. Further evaluation and demonstration of the system will be available on our website.","tags":[],"title":"A Person Re-Identification System For Mobile Devices","type":"publication"},{"authors":["GA Cushen","MS Nixon"],"categories":null,"content":"More detail can easily be written here using Markdown and $\\rm \\LaTeX$ math code.\n","date":1372647600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1372647600,"objectID":"2b4d919e3cf73dfcd0063c88fe01cb00","permalink":"https://sergiocarvalho-estatistico.github.io/publication/clothing-search/","publishdate":"2013-07-01T00:00:00-03:00","relpermalink":"/publication/clothing-search/","section":"publication","summary":"We present a mobile visual clothing search system whereby a smart phone user can either choose a social networking photo or take a new photo of a person wearing clothing of interest and search for similar clothing in a retail database. From the query image, the person is detected, clothing is segmented, and clothing features are extracted and quantized. The information is sent from the phone client to a server, where the feature vector of the query image is used to retrieve similar clothing products from online databases. The phone's GPS location is used to re-rank results by retail store location. State of the art work focuses primarily on the recognition of a diverse range of clothing offline and pays little attention to practical applications. Evaluated on a challenging dataset, the system is relatively fast and achieves promising results.","tags":[],"title":"Mobile visual clothing search","type":"publication"},{"authors":null,"categories":null,"content":" Welcome to Slides Academic\nFeatures  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides  Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E  Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;)  Math In-line math: $x + y = z$\nBlock math:\n$$f\\left( x \\right) = \\;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}}$$\nMatemática Block math:\n(i) $P(A) \\geq 0$\n(ii) Se $ \\displaystyle \\sum_{i=1}^{\\infty} P\\left( A_i \\right)$\n(iii) $P(\\Omega) = 1$.\nFragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}}  Press Space to play!\nOne  Two  Three \nA fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears  Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}}  Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view   Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links   night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links  Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/img/boards.jpg\u0026quot; \u0026gt;}} {{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}} {{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}  Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; }  Questions? Ask\nDocumentation\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"c2915ec5da95791851caafdcba9664af","permalink":"https://sergiocarvalho-estatistico.github.io/slides/example-slides/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/slides/example-slides/","section":"slides","summary":"Welcome to Slides Academic\nFeatures  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides  Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E  Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;)  Math In-line math: $x + y = z$","tags":null,"title":"Slides","type":"slides"},{"authors":null,"categories":null,"content":"\rR Markdown\rThis is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com.\nWhen you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:\nsummary(cars)\r## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00\r\rIncluding Plots\rYou can also embed plots, for example:\nNote that the echo = FALSE parameter was added to the code chunk to prevent printing of the R code that generated the plot.\n\r","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"f997b86eabf645d46f09b5b5b74278b9","permalink":"https://sergiocarvalho-estatistico.github.io/tutorial/teste/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/tutorial/teste/","section":"tutorial","summary":"R Markdown\rThis is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com.\nWhen you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:","tags":null,"title":"Teste Tutorial","type":"tutorial"}]